When to Use TypeScript Decorators
Decorators provide a clean way to extend functionality. You can use them to:

Log class instantiations, method calls, or property changes.
Restrict access to certain methods based on user roles.
Cache results with a cache decorator for better performance.
Examples of TypeScript Decorators
Class Decorator
A class decorator modifies an entire class. The example below adds a timestamp property to a class:


Copy Code

function Timestamp<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    timestamp = new Date();
  };
}

@Timestamp
class Message {
  constructor(public content: string) {}
}

const msg = new Message("Hello");
console.log(msg.timestamp); // Outputs current timestamp
Method Decorator
A method decorator modifies a method's behavior. The example below logs every method call:


Copy Code

function Log(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${methodName} with arguments:`, args);
    return originalMethod.apply(this, args);
  };
}

class Calculator {
  @Log
  add(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(3, 7);
// Output: Calling add with arguments: [3, 7]
Property Decorator
A property decorator modifies properties. The example below ensures a property always stores a capitalized string:


Copy Code

function Capitalize(target: any, propertyKey: string) {
  let value: string;

  const getter = function () {
    return value;
  };

  const setter = function (newVal: string) {
    value = newVal.charAt(0).toUpperCase() + newVal.slice(1);
  };

  Object.defineProperty(target, propertyKey, { get: getter, set: setter });
}

class Person {
  @Capitalize
  name: string = "";

  constructor(name: string) {
    this.name = name;
  }
}

const p = new Person("john");
console.log(p.name); // Output: John
Parameter Decorator
A parameter decorator modifies function parameters. The example below logs method arguments:


Copy Code

function LogParam(target: any, methodName: string, paramIndex: number) {
  console.log(`Parameter at index ${paramIndex} in method ${methodName} is logged.`);
}

class UserService {
  createUser(@LogParam name: string) {
    console.log(`User ${name} created.`);
  }
}

const service = new UserService();
service.createUser("Alice");
// Output: Parameter at index 0 in method createUser is logged.
Learn More About TypeScript Decorators
How to Create a Decorator
A decorator is a function that takes parameters based on where you apply it:

Class decorators receive the class constructor.
Method decorators receive the target, method name, and descriptor.
Property decorators receive the target and property key.
Parameter decorators receive the target, method name, and parameter index.
This decorator factory accepts arguments:


Copy Code

function Prefix(prefix: string) {
  return function (target: any, propertyKey: string) {
    let value: string;

    const getter = () => value;
    const setter = (newValue: string) => {
      value = `${prefix} ${newValue}`;
    };

    Object.defineProperty(target, propertyKey, { get: getter, set: setter });
  };
}

class Book {
  @Prefix("Title:")
  name: string = "";

  constructor(name: string) {
    this.name = name;
  }
}

const b = new Book("TypeScript Guide");
console.log(b.name); // Output: Title: TypeScript Guide
Using Decorators Without a Class
Decorators usually work with classes, but you can apply them to standalone functions using higher-order functions:


Copy Code

function MeasureTime(fn: Function) {
  return function (...args: any[]) {
    console.time("Execution time");
    const result = fn(...args);
    console.timeEnd("Execution time");
    return result;
  };
}

const slowFunction = MeasureTime(() => {
  for (let i = 0; i < 1e6; i++) {}
});

slowFunction(); // Outputs execution time
Async Decorator
An async decorator handles asynchronous function calls. The example below retries an async operation on failure:


Copy Code

function Retry(retries: number) {
  return function (target: any, methodName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = async function (...args: any[]) {
      let attempts = 0;
      while (attempts < retries) {
        try {
          return await originalMethod.apply(this, args);
        } catch (error) {
          attempts++;
          console.log(`Retry ${attempts} for ${methodName}`);
        }
      }
      throw new Error(`${methodName} failed after ${retries} attempts`);
    };
  };
}

class API {
  @Retry(3)
  async fetchData() {
    throw new Error("Network error");
  }
}

const api = new API();
api.fetchData().catch(console.error);
Cache Decorator
A cache decorator stores function results to improve performance:


Copy Code

function Cache(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const cache = new Map();
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    const key = JSON.stringify(args);
    if (!cache.has(key)) {
      cache.set(key, originalMethod.apply(this, args));
    }
    return cache.get(key);
  };
}

class MathOperations {
  @Cache
  factorial(n: number): number {
    return n <= 1 ? 1 : n * this.factorial(n - 1);
  }
}

const math = new MathOperations();
console.log(math.factorial(5)); // Cached result used for efficiency
Fastify Decorators
Fastify, a web framework, supports decorators to extend server functionality:


Copy Code

import Fastify from "fastify";

const fastify = Fastify();

fastify.decorate("greet", (name: string) => `Hello, ${name}!`);

fastify.get("/greet/:name", (request, reply) => {
  reply.send({ message: fastify.greet(request.params.name) });
});

fastify.listen(3000, () => console.log("Server running..."));

// 1. Create the Decorator Factory
function LogParameter(prefix: string) {
  // 2. Return the actual decorator function
  return function (
    target: Object,
    propertyKey: string | symbol,
    parameterIndex: number
  ) {
    console.log(
      `${prefix} - Parameter at index ${parameterIndex} of method '${String(
        propertyKey
      )}' in class '${target.constructor.name}'`
    );
  };
}

class MyClass {
  myMethod(
    @LogParameter("INFO") param1: string,
    @LogParameter("DEBUG") param2: number
  ) {
    console.log(`myMethod called with: ${param1}, ${param2}`);
  }
}

const instance = new MyClass();
instance.myMethod("hello", 123);




class_decorator.ts
function logClass(target: any) {
 
  // save a reference to the original constructor
  var original = target;
 
  // a utility function to generate instances of a class
  function construct(constructor, args) {
    var c : any = function () {
      return constructor.apply(this, args);
    }
    c.prototype = constructor.prototype;
    return new c();
  }
 
  // the new constructor behaviour
  var f : any = function (...args) {
    console.log("New: " + original.name);
    return construct(original, args);
  }
 
  // copy prototype so intanceof operator still works
  f.prototype = original.prototype;
 
  // return new constructor (will override original)
  return f;
}

@logClass
class Person { 

  public name: string;
  public surname: string;

  constructor(name : string, surname : string) { 
    this.name = name;
    this.surname = surname;
  }
}

var p = new Person("remo", "jansen");
configurable_decorator.ts
@logClassWithArgs({ when : { name : "remo"} })
class Person {
  public name: string;
 
  // ...
}

function logClassWithArgs(filter: Object) {
    return (target: Object) => {
        // implement class decorator here, the class decorator
        // will have access to the decorator arguments (filter)
        // because they are  stored in a closure
    }
}
decorator_factory.ts
function log(...args : any[]) {
  switch(args.length) {
    case 1:
      return logClass.apply(this, args);
    case 2:
      return logProperty.apply(this, args);
    case 3:
      if(typeof args[2] === "number") {
        return logParameter.apply(this, args);
      }
      return logMethod.apply(this, args);
    default:
      throw new Error();
  }
}
method_decorator.ts
function logMethod(target, key, descriptor) {
 
    // save a reference to the original method this way we keep the values currently in the
    // descriptor and don't overwrite what another decorator might have done to the descriptor.
    if(descriptor === undefined) {
      descriptor = Object.getOwnPropertyDescriptor(target, key);
    }
    var originalMethod = descriptor.value;
 
    //editing the descriptor/value parameter
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var a = args.map(function (a) { return JSON.stringify(a); }).join();
        // note usage of originalMethod here
        var result = originalMethod.apply(this, args);
        var r = JSON.stringify(result);
        console.log("Call: " + key + "(" + a + ") => " + r);
        return result;
    };
 
    // return edited descriptor as opposed to overwriting the descriptor
    return descriptor;
}

class Person { 
  
  public name: string;
  public surname: string;
  
  constructor(name : string, surname : string) { 
    this.name = name;
    this.surname = surname;
  }
  
  @logMethod
  public saySomething(something : string, somethingElse : string) : string { 
    return this.name + " " + this.surname + " says: " + something + " " + somethingElse; 
  }
}

var p = new Person("remo", "jansen");
p.saySomething("I love playing", "halo");
parameter_decorator.ts
function logParameter(target: any, key : string, index : number) {
  var metadataKey = `__log_${key}_parameters`;
  if (Array.isArray(target[metadataKey])) {
    target[metadataKey].push(index);
  }
  else {
    target[metadataKey] = [index];
  }
}

function logMethod(target, key, descriptor) {
	
    if(descriptor === undefined) {
      descriptor = Object.getOwnPropertyDescriptor(target, key);
    }
    var originalMethod = descriptor.value;

    //editing the descriptor/value parameter
	  descriptor.value = function (...args: any[]) {

    	var metadataKey = `__log_${key}_parameters`;
    	var indices = target[metadataKey];

  		if (Array.isArray(indices)) { 
  			for (var i = 0; i < args.length; i++) { 
  		
  				if (indices.indexOf(i) !== -1) { 
  		
  				var arg = args[i];
  				var argStr = JSON.stringify(arg) || arg.toString();
  				console.log(`${key} arg[${i}]: ${argStr}`);
  				}
  			}
  			var result = originalMethod.apply(this, args);
  			return result;
  		}
  		else {
  			var a = args.map(a => (JSON.stringify(a) || a.toString())).join();
  			var result = originalMethod.apply(this, args);
  			var r = JSON.stringify(result);
  			console.log(`Call: ${key}(${a}) => ${r}`);
  			return result;
  		}
  	}

    // return edited descriptor as opposed to overwriting the descriptor
    return descriptor;
}

class Person { 

  public name: string;
  public surname: string;

  constructor(name : string, surname : string) { 
    this.name = name;
    this.surname = surname;
  }
  
  @logMethod
  public saySomething(@logParameter something : string, somethingElse : string) : string { 
    return this.name + " " + this.surname + " says: " + something + " " + somethingElse; 
  }
}

var p = new Person("remo", "jansen");
p.saySomething("I love playing", "halo");
property_decorator.ts
function logProperty(target: any, key: string) {
 
  // property value
  var _val = this[key];
 
  // property getter
  var getter = function () {
    console.log(`Get: ${key} => ${_val}`);
    return _val;
  };
 
  // property setter
  var setter = function (newVal) {
    console.log(`Set: ${key} => ${newVal}`);
    _val = newVal;
  };
 
  // Delete property.
  if (delete this[key]) {
 
    // Create new property with getter and setter
    Object.defineProperty(target, key, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true
    });
  }
}

class Person { 
  @logProperty
  public name: string;
  public surname: string;

  constructor(name : string, surname : string) { 
    this.name = name;
    this.surname = surname;
  }
}

var p = new Person("remo", "Jansen");
p.name = "Remo";
var n = p.name;
reflect_metadata.ts
function logParamTypes(target : any, key : string) {
  var types = Reflect.getMetadata("design:paramtypes", target, key);
  var s = types.map(a => a.name).join();
  console.log(`${key} param types: ${s}`);
}

class Foo {}
interface IFoo {}

class Demo{
  @logParameters
  doSomething(
    param1 : string,
    param2 : number,
    param3 : Foo,
    param4 : { test : string },
    param5 : IFoo,
    param6 : Function,
    param7 : (a : number) => void,
  ) : number {
      return 1
  }
}

// doSomething param types: String, Number, Foo, Object, Object, Function, Function

